import math
import random
import sys
import PyQt4.Qwt5 as Qwt
import numpy
import serial
import time
import os

from PyQt4.Qwt5.anynumpy import *
from PyQt4 import QtGui, QtCore
from PyQt4.QtOpenGL import *
from OpenGL.GL import *
from OpenGL.GLU import *
from OpenGL.GLUT import *
from serial.tools import list_ports

XYPLOT_TIME = 100
TIMER_UPDATE_RATE = 25

NAV_IDLE          = 0     
NAV_CAL_COMPLETE  = 1 
NAV_CAL_SAMP_COMP = 2
NAV_MAG_CAL       = 3
NAV_ACCEL_CAL     = 4
NAV_DCM_INIT      = 5
NAV_ACTIVE        = 6
NAV_ERROR         = 7

TEST_MAG_DATA = 0
magTestData = [[ 0.27, -0.66,  0.91],
               [ 0.33, -0.85, -0.76],
               [ 0.3,   0.95, -0.8 ],
               [ 0.53,  1.11,  0.36],
               [ 0.38,  0.48,  1.  ],
               [ 1.04,  0.3,  -0.39],
               [ 0.09,  0.05, -1.18],
               [-1.34,  0.03, -0.61],
               [-1.39,  0.12,  0.57],
               [-0.44, -0.07,  1.18],
               [-0.21, -1.17,  0.51],
               [-0.67, -1.23, -0.09],
               [ 0.18, -1.03, -0.65],
               [-0.46, -1.01, -0.73],
               [ 0.51,  0.8,   0.76],
               [ 0.15, -0.31,  1.12]]

magTestRotMat = numpy.matrix([[0.46999999999999997, 0.87, 0.10000000000000001], 
                              [0.88, -0.46999999999999997, -0.01], 
                              [-0.029999999999999999, -0.10000000000000001, 0.98999999999999999]])
magTestScale = numpy.matrix([[0.72999999999999998], [0.75], [0.81999999999999995]])
magTestBias = numpy.matrix([[-0.20000000000000001], [0.040000000000000001], [0.0]])
magTestData2 = numpy.zeros([16,3])

class QColorScheme():
    """Class to ease custom colors of PyQt apps
    baseColor: This is the main background color.
    highlightColor: Typically contrasting the baseColor (e.g. used to highlight current focus)
    spread: Float value indicating the brightness range generated by generateColors (1.5-2.0 seems most reasonable)
    """
    
    def __init__(self,baseColor=QtGui.QColor(50,50,50), highlightColor=QtGui.QColor("yellow"), spread=2.5):
        """Constructor
        By default a nukeish color scheme (dark slate + orange highlight) is created
        This can be overriden by either supplying colors or by loading a different
        scheme from disc via the load settings
        """
        self.palette = QtGui.QPalette()
        self.baseColor = baseColor
        self.highlightColor = highlightColor
        self.spread = spread
        self.generateScheme()
        QtGui.QApplication.setStyle("Plastique")
    
    def __lightness(self, color):
        """Returns simple averaged lightness of a QColor
        Newer Qt Versions implement this as part of QColor
        Reimplemented for backwards-compatibility
        """
        hsv = color.toHsv()
        return hsv.valueF()
    
    def generateScheme(self, apply=True):
        """Generate color palette
        By default the generated palette is also applied to the whole application
        To override supply the apply=False argument
        """
        BASE_COLOR = self.baseColor
        HIGHLIGHT_COLOR = self.highlightColor
        BRIGHTNESS_SPREAD = self.spread
        
        if self.__lightness(BASE_COLOR) > 0.5:
            SPREAD = 100/BRIGHTNESS_SPREAD
        else:
            SPREAD = 100*BRIGHTNESS_SPREAD
        
        if self.__lightness(HIGHLIGHT_COLOR)>0.6:
            HIGHLIGHTEDTEXT_COLOR= BASE_COLOR.darker(SPREAD*2)
        else:
            HIGHLIGHTEDTEXT_COLOR= BASE_COLOR.lighter(SPREAD*2)
        
        self.palette.setBrush(QtGui.QPalette.Window, QtGui.QBrush(BASE_COLOR))
        self.palette.setBrush(QtGui.QPalette.WindowText, QtGui.QBrush(BASE_COLOR.lighter(SPREAD)))
        self.palette.setBrush(QtGui.QPalette.Foreground, QtGui.QBrush(BASE_COLOR.lighter(SPREAD)))
        self.palette.setBrush(QtGui.QPalette.Base, QtGui.QBrush(BASE_COLOR))
        self.palette.setBrush(QtGui.QPalette.AlternateBase, QtGui.QBrush(BASE_COLOR.darker(SPREAD)))
        self.palette.setBrush(QtGui.QPalette.ToolTipBase, QtGui.QBrush(BASE_COLOR))
        self.palette.setBrush(QtGui.QPalette.ToolTipText, QtGui.QBrush(BASE_COLOR.lighter(SPREAD)))
        self.palette.setBrush(QtGui.QPalette.Text, QtGui.QBrush(BASE_COLOR.lighter(SPREAD*1.2)))
        self.palette.setBrush(QtGui.QPalette.Button, QtGui.QBrush(BASE_COLOR.lighter(SPREAD/3)))
        self.palette.setBrush(QtGui.QPalette.ButtonText, QtGui.QBrush(BASE_COLOR.lighter(SPREAD)))
        self.palette.setBrush(QtGui.QPalette.BrightText, QtGui.QBrush(QtGui.QColor(240, 240, 240)))
        
        self.palette.setBrush(QtGui.QPalette.Light, QtGui.QBrush(BASE_COLOR.lighter(SPREAD)))
        self.palette.setBrush(QtGui.QPalette.Midlight, QtGui.QBrush(BASE_COLOR.lighter(SPREAD/2)))
        self.palette.setBrush(QtGui.QPalette.Dark, QtGui.QBrush(BASE_COLOR.darker(SPREAD)))
        self.palette.setBrush(QtGui.QPalette.Mid, QtGui.QBrush(BASE_COLOR))    
        self.palette.setBrush(QtGui.QPalette.Shadow, QtGui.QBrush(BASE_COLOR.darker(SPREAD)))    
        
        self.palette.setBrush(QtGui.QPalette.Highlight, QtGui.QBrush(HIGHLIGHT_COLOR))
        self.palette.setBrush(QtGui.QPalette.HighlightedText, QtGui.QBrush(HIGHLIGHTEDTEXT_COLOR))
        if apply:
            QtGui.QApplication.setPalette(self.palette)   
    
    def applyStyle(self, target=QtGui.QApplication):
        """Apply the color scheme in self.palette
        When called without arguments the whole application will be styled
        If a widget is supplied as argument only this widget will be styled
        """
        target.setPalette(self.palette)
    
    def colorFromStringTuple(self,tuple):
        return QtGui.QColor(int(tuple[0]),int(tuple[1]),int(tuple[2]))
        
    def loadSimpleScheme(self, file, apply=True):
        scheme = configparser.ConfigParser()
        scheme.read(file)
        self.baseColor = self.colorFromStringTuple(scheme.get("AutoColors", "baseColor").split(","))
        self.highlightColor = self.colorFromStringTuple(scheme.get("AutoColors", "highlightColor").split(","))
        self.spread = float(scheme.get("AutoColors", "spread"))
        if apply:
            self.generateScheme()
        else:
            self.generateScheme(apply=False)
    
    def loadScheme(self, file):
        """TODO: Implement
        """
        raise NotImplementedError
    
class SerialReader(QtCore.QThread):
    def __init__(self, name, serialPort):
        QtCore.QThread.__init__(self)
        self.name = name
        self.serialPort = serialPort
        self.signal = QtCore.SIGNAL("signal")
        
    def run(self):
        while( True):
            buffer = self.serialPort.readline().decode("utf-8")
            mess = buffer.split()
            if( len(mess) > 1):           
                if( mess[0] == '#csd'):
                    mess = mess[1:len(mess)]
                    self.emit(self.signal, mess)
                elif( mess[0] == '#calmsg'):
                    mess = mess[1:len(mess)]
                    self.emit(self.signal, mess)
                    
class AHRSPlot(Qwt.QwtPlot):

    def __init__(self, *args, plotName, yName):
        Qwt.QwtPlot.__init__(self, *args)

        self.setCanvasBackground(QtCore.Qt.black)
        self.alignScales()

        # Initialize data
        self.x = numpy.arange(0,XYPLOT_TIME,TIMER_UPDATE_RATE/1000)
        self.data1 = numpy.zeros(len(self.x), Float)
        self.data2 = numpy.zeros(len(self.x), Float)
        #self.data3 = numpy.zeros(len(self.x), Float)
        self.data4 = numpy.zeros(len(self.x), Float)
        
        self.setTitle(plotName)
        self.insertLegend(Qwt.QwtLegend(), Qwt.QwtPlot.BottomLegend);
        self.gridy = Qwt.QwtPlotGrid();
        pen = QtGui.QPen(QtCore.Qt.gray, .4, QtCore.Qt.DashLine)
        self.gridy.setPen( pen)
        self.gridy.enableX(False)
                
        self.plot1 = Qwt.QwtPlotCurve( "corrected")
        self.plot1.attach(self)
        pen = QtGui.QPen(QtCore.Qt.yellow, 2, QtCore.Qt.SolidLine)
        self.plot1.setPen(pen)
        
        self.plot2 = Qwt.QwtPlotCurve( "raw")
        self.plot2.attach(self)
        self.plot2.setPen(QtGui.QPen(QtCore.Qt.green))
        
        #self.plot3 = Qwt.QwtPlotCurve( "disabled")
        #self.plot3.attach(self)
        #pen = QtGui.QPen(QtCore.Qt.white, .1, QtCore.Qt.DashLine)
        #self.plot3.setPen(pen)

        self.plot4 = Qwt.QwtPlotCurve( "residual")
        self.plot4.attach(self)
        pen = QtGui.QPen(QtCore.Qt.red, .1, QtCore.Qt.SolidLine)
        self.plot4.setPen(pen)
                
        self.plot1.setYAxis(Qwt.QwtPlot.yLeft)
        self.plot2.setYAxis(Qwt.QwtPlot.yLeft)    
        #self.plot3.setYAxis(Qwt.QwtPlot.yRight) 
        self.plot4.setYAxis(Qwt.QwtPlot.yLeft)
                        
        self.gridy.attach(self)
                
#         mY = Qwt.QwtPlotMarker()
#         mY.setLabelAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTop)
#         mY.setLineStyle(Qwt.QwtPlotMarker.HLine)
#         mY.setYValue(0.0)
#         mY.attach(self)
#         self.peakMarker = m = Qwt.QwtPlotMarker()
#         m.setLabelAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignBottom)
#         text = Qwt.QwtText('')
#         text.setColor(QtCore.Qt.red)
#         text.setBackgroundBrush(QtGui.QBrush(self.canvasBackground()))
#         text.setFont(QtGui.QFont(self.fontInfo().family(), 12, QtGui.QFont.Bold))
#         
#         m.setLabel(text)
#         m.setSymbol(Qwt.QwtSymbol(Qwt.QwtSymbol.Diamond,
#                               QtGui.QBrush(QtCore.Qt.white),
#                               QtGui.QPen(QtCore.Qt.green),
#                               QtCore.QSize(14,14)))
#         m.attach(self)

        self.setAxisTitle(Qwt.QwtPlot.xBottom, "Time (seconds)")
        self.setAxisTitle(Qwt.QwtPlot.yLeft, yName)
        #self.setAxisTitle(Qwt.QwtPlot.yRight, "Attitude Correction Disabled")
        #self.enableAxis(Qwt.QwtPlot.yRight, True)
               
        self.setAxisScale(self.yLeft, -180, 180)
        self.setAxisScale(self.xBottom, 0, XYPLOT_TIME)
        #self.setAxisScale(self.yRight, 0, 1)
        self.setAxisAutoScale(self.yLeft)
                
        self.zoomer = Qwt.QwtPlotZoomer(Qwt.QwtPlot.xBottom,
                                        Qwt.QwtPlot.yLeft,
                                        Qwt.QwtPicker.DragSelection,
                                        Qwt.QwtPicker.AlwaysOff,
                                        self.canvas())
        self.zoomer.setMousePattern( Qwt.QwtEventPattern.MouseSelect2,
                                     QtCore.Qt.RightButton, QtCore.Qt.ControlModifier)
        self.zoomer.setMousePattern( Qwt.QwtEventPattern.MouseSelect3,
                                     QtCore.Qt.RightButton)
        self.zoomer.setRubberBandPen(QtCore.Qt.white)
        self.zoomer.setTrackerPen(QtCore.Qt.white)
               
        #self.zoomer.connect(self.zoomer, QtCore.SIGNAL('moved(const QwtPolygon&)'), self.zoomerMoved)
        
        self.startTimer(TIMER_UPDATE_RATE)

    def mouseDoubleClickEvent(self, event):
        self.setAxisAutoScale(self.yLeft)
        self.setAxisAutoScale(self.yRight)
        self.setAxisAutoScale(self.xBottom)
        
    def updateAngles(self, correctedAngle, rawAngle, kalmanDisabled, residual):
        self.data4 = numpy.roll(self.data4, 1, axis=0)
        #self.data3 = numpy.roll(self.data3, 1, axis=0)
        self.data2 = numpy.roll(self.data2, 1, axis=0)
        self.data1 = numpy.roll(self.data1, 1, axis=0)
        
        self.data1[0] = correctedAngle
        self.data2[0] = rawAngle
        #self.data3[0] = kalmanDisabled
        self.data4[0] = residual
                
    def alignScales(self):
        self.canvas().setFrameStyle(QtGui.QFrame.Box | QtGui.QFrame.Plain)
        self.canvas().setLineWidth(1)
        for i in range(Qwt.QwtPlot.axisCnt):
            scaleWidget = self.axisWidget(i)
            if scaleWidget:
                scaleWidget.setMargin(0)
            scaleDraw = self.axisScaleDraw(i)
            if scaleDraw:
                scaleDraw.enableComponent(
                    Qwt.QwtAbstractScaleDraw.Backbone, False)

    def timerEvent(self, e):
        
        self.plot2.setData(self.x, self.data2)
        #self.plot3.setData(self.x, self.data3)
        self.plot4.setData(self.x, self.data4+self.data1)
        self.plot1.setData(self.x, self.data1)
        self.replot()
 
class XyPlotPitchRoll(QGLWidget):
    
    def __init__(self, parent):
        
        QGLWidget.__init__(self, parent)   
        self.setMinimumSize(250, 250)
        self.rollRad = 0
        self.pitchRad = 0
        self.rollDeg = 0
        self.pitchDeg = 0
        self.useRawMeas = False
        
    def setRollPitch(self, euler): 
        if( self.useRawMeas == False):
            #Grab corrected roll
            self.rollDeg = euler[0]
            self.rollRad = euler[0]*3.14159/180.0
            #Grab corrected pitch
            self.pitchDeg = euler[2]
            self.pitchRad = euler[2]*3.14159/180.0   
        else:
            #Grab raw roll
            self.rollDeg = euler[1]
            self.rollRad = euler[1]*3.14159/180.0
            #Grab raw pitch
            self.pitchDeg = euler[3]
            self.pitchRad = euler[3]*3.14159/180.0 
                        
        self.update()
        
    def paintGL(self):
        
        # clear color and depth buffers
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        glEnable (GL_BLEND);
        glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);        
        glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);     
        glEnable(GL_LIGHTING)
        
        #Draw sky
        glTranslatef(0,0,0);
        glClipPlane( GL_CLIP_PLANE1,(numpy.sin(-self.rollRad),numpy.cos(-self.rollRad), numpy.sin(self.pitchRad), 0));
        glEnable(GL_CLIP_PLANE1);
        glPushMatrix();
        glColor3f(.52,.8,.98)
        gluSphere(self.g_quadratic2, .8, 100, 100)
        glDisable(GL_CLIP_PLANE1)
        glPopMatrix()
        
        #Draw Ground
        glClipPlane( GL_CLIP_PLANE1,(-numpy.sin(-self.rollRad),-numpy.cos(-self.rollRad), -numpy.sin(self.pitchRad), 0));
        glEnable(GL_CLIP_PLANE1);  
        glPushMatrix();        
        glColor3f(.13,.55,.13)
        gluSphere(self.g_quadratic2, .8, 100, 100)
        glDisable(GL_CLIP_PLANE1) 
        glPopMatrix()

        #Draw platform reference
        glDisable(GL_LIGHTING)
        glColor3f(1,0,0)
        glLineWidth (5)
        glBegin(GL_LINE_STRIP) 
        glVertex3f(-.2, 0, .81)    
        glVertex3f(.2, 0, .81)
        glVertex3f(0, 0, .81)        
        glVertex3f(0, .1, .81)         
        glEnd() 

        #Show digital display
        #Draw digital display
        glLineWidth (2);
        glColor3f(0,0,0);
        glBegin(GL_QUADS)
        glVertex3f(-.25, -.3, .81) 
        glVertex3f( .25, -.3, .81)        
        glVertex3f( .25,  -.1, .81)   
        glVertex3f(-.25,  -.1, .81)         
        glEnd()
        
        p = numpy.round(self.pitchDeg,1)

        glColor3f(1,1,1)    
        glPushMatrix();
        
        if p < -99:
            glTranslatef(-.01, -.26, .82)
        elif p < -9:
            glTranslatef(.04, -.26, .82)
        elif p < 0:
            glTranslatef(.07, -.26, .82)            
        elif p < 10:
            glTranslatef(.12, -.26, .82)
        elif p < 100:
            glTranslatef(.07, -.26, .82)
        else:
            glTranslatef(.04, -.26, .82)

        glScalef(.0004, .0004, .0004)
        glLineWidth(1);           
        s = "%3.1f" % (p)  
  
        for ch in str(s):
            glutStrokeCharacter(GLUT_STROKE_MONO_ROMAN, ord(ch));
        glPopMatrix(); 
 
        #Show digital display
        p = numpy.round(self.rollDeg,1)

        glPushMatrix();

        if p < -99:
            glTranslatef(-.01, -.18, .82)
        elif p < -9:
            glTranslatef(.04, -.18, .82)
        elif p < 0:
            glTranslatef(.07, -.18, .82)            
        elif p < 10:
            glTranslatef(.12, -.18, .82)
        elif p < 100:
            glTranslatef(.07, -.18, .82)
        else:
            glTranslatef(.04, -.18, .82)
                       
        glScalef(.0004, .0004, .0004)
        glLineWidth(1);           
        s = "%3.1f" % (p)  

        for ch in str(s):
            glutStrokeCharacter(GLUT_STROKE_MONO_ROMAN, ord(ch));
        glPopMatrix(); 
    
        glPushMatrix();
        glTranslatef(-.25, -.18, .82)
        glScalef(.0004, .0004, .0004)
        glLineWidth(1);                   
        for ch in str('Roll'):
            glutStrokeCharacter(GLUT_STROKE_MONO_ROMAN, ord(ch));
        glPopMatrix();
        
        glPushMatrix();
        glTranslatef(-.25, -.26, .82)
        glScalef(.0004, .0004, .0004)
        glLineWidth(1);                   
        for ch in str('Pitch'):
            glutStrokeCharacter(GLUT_STROKE_MONO_ROMAN, ord(ch));
        glPopMatrix();    
        glFlush()

    def resizeGL(self, widthInPixels, heightInPixels):
        glViewport(0, 0, widthInPixels, heightInPixels)

    def initializeGL(self):
        glutInit()
        # set viewing projection
        glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB)
        
        glMatrixMode(GL_PROJECTION)
        glFrustum(-0.5, 0.5, -0.5, 0.5, 1.0, 3.0)
        
        # position viewer
        glMatrixMode(GL_MODELVIEW)
        glTranslatef(0.0, 0.0, -2.0)

        # position object
        glRotatef(0.0, 1.0, 0.0, 0.0)
        glRotatef(0.0, 0.0, 1.0, 0.0)
        glRotatef(0.0, 0.0, 0.0, 1.0)
   
        glEnable(GL_DEPTH_TEST)
        glEnable(GL_LIGHTING)
        glEnable(GL_LIGHT0)
        glEnable ( GL_COLOR_MATERIAL )
        glDepthFunc(GL_LEQUAL)
        glColorMaterial( GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE)
        glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE)
        
        glClearColor( .3,.3,.3, 0)     
        self.g_quadratic2= gluNewQuadric()    
        gluQuadricDrawStyle(self.g_quadratic2, GLU_FILL)
        gluQuadricNormals(self.g_quadratic2,  GLU_FLAT)        
        glLightfv(GL_LIGHT0, GL_POSITION, (.0, .5, .75, 0.0))
                              
class XyPlotCompass(QGLWidget):
     
    def __init__(self, parent):
        QGLWidget.__init__(self, parent)
        self.setMinimumSize(250, 250)
        self.yawRad = 0
        self.yawDeg = 0
        self.useRawMeas = False
        
    def setYaw(self, euler): 
        
        if( self.useRawMeas == False):
            #Grab corrected yaw
            self.yawDeg = euler[4]
            self.yawRad = (euler[4]*3.14159/180.0)# + (3.14159/2)
        else:
            #Grab raw yaw
            self.yawDeg = euler[5]
            self.yawRad = (euler[5]*3.14159/180.0)# + (3.14159/2)  
                      
        self.update()
               
    def paintGL(self):

        # clear color and depth buffers
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        glEnable (GL_BLEND);
        glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);        
        glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);   
        glEnable(GL_LIGHTING)

        glTranslatef(0,0,0);
        glPushMatrix();
        gluQuadricOrientation(g_quadratic,GLU_OUTSIDE)
        glColor3f(1,.65,0)
        gluCylinder(g_quadratic, .85, .85, .3, 100, 100)
        gluCylinder(g_quadratic, .88, .88, .3, 100, 100)
        glPopMatrix()
        
        glPushMatrix();
        glTranslatef(0,0,.3);
        gluDisk( g_quadratic, .85, .88, 100, 100) 
        glPopMatrix()
        
        glPushMatrix();
        glTranslatef(0,0,.2);
        gluQuadricOrientation(g_quadratic,GLU_OUTSIDE)
        glPopMatrix()

        glPushMatrix();
        glTranslatef(0,0,.2);        
        glColor3f(1,.65,0)
        gluSphere(g_quadratic, .05, 100, 100)     
        glPopMatrix()
 
        glPushMatrix();
        glTranslatef(0,0,.2);           
        glColor3f(1,1,1)
        gluDisk( g_quadratic, .05, .6, 100, 100) 
        glPopMatrix()

        glPushMatrix();
        glTranslatef(0,0,.2);         
        glColor3f(0, 0, 0)
        gluDisk( g_quadratic, .6, .65, 100, 100)
        glPopMatrix()

        glPushMatrix();
        glTranslatef(0,0,.2);            
        glColor3f(1,1,1)
        gluDisk( g_quadratic, .65, .85, 100, 100)
        glPopMatrix()
        
        glColor3f(0,0,0)
        glEnable(GL_LINE_SMOOTH)  
        glHint(GL_LINE_SMOOTH_HINT, GL_NICEST)    

        #Draw West line
        glLineWidth (3);
        glBegin(GL_LINE_STRIP)
        glVertex3f(-.60, 0, .21)    
        glVertex3f(-.50, 0, .21)          
        glEnd() 
  
        #Draw North line
        glLineWidth (3);
        glBegin(GL_LINE_STRIP)

        glVertex3f(0, .6, .21)    
        glVertex3f(0, .5, .21)          
        glEnd() 
        
        #Draw East line
        glLineWidth (3);
        glBegin(GL_LINE_STRIP)

        glVertex3f(.60, 0, .21)    
        glVertex3f(.50, 0, .21)          
        glEnd() 
 
        #Draw South line
        glLineWidth (3);
        glBegin(GL_LINE_STRIP)

        glVertex3f(0, -.5, .21)    
        glVertex3f(0, -.6, .21)          
        glEnd() 
      
        glPushMatrix();
        glTranslatef(-.8, -.04, .21);
        glScalef(.001, .001, .001);
        glLineWidth(2);        
        for ch in str('W'):
            glutStrokeCharacter(GLUT_STROKE_ROMAN, ord(ch));
        glPopMatrix();
        
        glPushMatrix();
        glTranslatef(.7, -.04, .21);
        glScalef(.001, .001, .001);
        glLineWidth(2);        
        for ch in str('E'):
            glutStrokeCharacter(GLUT_STROKE_ROMAN, ord(ch));
        glPopMatrix();  
 
        glPushMatrix();
        glColor3f(1,0,0)
        glTranslatef(-.04, .7, .21);
        glScalef(.001, .001, .001);
        glLineWidth(2);        
        for ch in str('N'):
            glutStrokeCharacter(GLUT_STROKE_ROMAN, ord(ch));
        glPopMatrix();  
  
        glPushMatrix();
        glColor3f(0,0,0)
        glTranslatef(-.04, -.8, .21);
        glScalef(.001, .001, .001);
        glLineWidth(2);        
        for ch in str('S'):
            glutStrokeCharacter(GLUT_STROKE_ROMAN, ord(ch));
        glPopMatrix(); 
             
        phase = self.yawRad

        #Draw needle
        glLineWidth (1);
        glColor3f(1,0,0);
        glBegin(GL_TRIANGLES)
        glVertex3f(.5*numpy.sin(phase), .5*numpy.cos(phase), .23)
        glVertex3f(.1*numpy.sin(phase+(3.14159/2)), .1*numpy.cos(phase+(3.14159/2)), .23)    
        glVertex3f(.1*numpy.sin(phase-(3.14159/2)), .1*numpy.cos(phase-(3.14159/2)), .23)      
        glEnd() 

        #Draw digital display
        glDisable(GL_LIGHTING)
        glLineWidth (2);
        glColor3f(0,0,0);
        glBegin(GL_QUADS)
        glVertex3f(-.35, -.3, .21) 
        glVertex3f( .35, -.3, .21)        
        glVertex3f( .35,  -.1, .21)   
        glVertex3f(-.35,  -.1, .21)         
        glEnd()

        glPushMatrix();
        glColor3f(1,1,1)
        
        p = numpy.round(phase*180/3.14159,1)
        
        if p < -180:
            p = p + 360

        if p < -99:
            glTranslatef(-.28, -.28, .22)
        elif p < 0:
            glTranslatef(-.2, -.28, .22)
        elif p < 10:
            glTranslatef(-.03, -.28, .22)
        else:
            glTranslatef(-.1, -.28, .22)
            
        glScalef(.001, .001, .001);
        glLineWidth(1);           
        s = "%3.1f" % (p)  
        #print (s)       
        for ch in str(s):
            glutStrokeCharacter(GLUT_STROKE_MONO_ROMAN, ord(ch));
        glPopMatrix(); 
        
        glFlush()
        #glutSwapBuffers()
        
    def resizeGL(self, widthInPixels, heightInPixels):
        glViewport(0, 0, widthInPixels, heightInPixels)

    def initializeGL(self):
        glutInit()
        global g_quadratic
        # set viewing projection
        glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB)
        glMatrixMode(GL_PROJECTION)
        glFrustum(-0.5, 0.5, -0.5, 0.5, 1.0, 3.0)

        # position viewer
        glMatrixMode(GL_MODELVIEW)
        glTranslatef(0.0, 0.0, -2.0)

        # position object
        glRotatef(0.0, 1.0, 0.0, 0.0)
        glRotatef(0.0, 0.0, 1.0, 0.0)
        glRotatef(0.0, 0.0, 0.0, 1.0)
   
        glEnable(GL_DEPTH_TEST)
        glEnable(GL_LIGHTING)
        glEnable(GL_LIGHT0)
        glEnable ( GL_COLOR_MATERIAL )
        glDepthFunc(GL_LEQUAL)
        glColorMaterial( GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE)
        glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE)
        
        glClearColor( .3,.3,.3, 0)
        glRotatef(-30, 1.0, 0.0, 0.0)
        glRotatef(30, 0.0, 1.0, 0.0)             
        g_quadratic = gluNewQuadric()    
        gluQuadricDrawStyle(g_quadratic, GLU_FILL)
        gluQuadricNormals(g_quadratic,  GLU_FLAT)
        glLightfv(GL_LIGHT0, GL_POSITION, (-.01, 0, .15, 0.0))
                                             
class Viewer3DWidget(QGLWidget):

    def __init__(self, parent):
        QGLWidget.__init__(self, parent)
        self.setMouseTracking(True)
        self.setMinimumSize(250, 250)

        self.isPressed = False
        self.oldx = self.oldy = 0
        self.delta_x = self.delta_y = 0
        self.rollDeg = 0
        self.pitchDeg = 0
        self.yawDeg = 0
        self.rollRad = 0
        self.pitchRad = 0
        self.yawRad = 0
        self.rollDelta = 0
        self.pitchDelta = 0
        self.yawDelta = 0
        self.prevRollDeg = 0
        self.prevPitchDeg = 0
        self.prevYawDeg = 0
        self.useRawMeas = False
        
    def setRollPitchYaw(self, euler): 
        #Grab corrected roll
        
        if( self.useRawMeas == False):
            self.rollDelta = euler[0] - self.rollDeg
            self.pitchDelta = euler[2] - self.pitchDeg 
            self.yawDelta = euler[4] - self.yawDeg 
                   
            self.rollDeg = euler[0]
            self.rollRad = euler[0]*3.14159/180.0
            #Grab corrected pitch
            self.pitchDeg = euler[2]
            self.pitchRad = euler[2]*3.14159/180.0   
            #Grab corrected yaw
            self.yawDeg = -euler[4]
            self.yawRad = -euler[4]*3.14159/180.0   
        else:
            self.rollDelta = euler[1] - self.rollDeg
            self.pitchDelta = euler[3] - self.pitchDeg 
            self.yawDelta = euler[5] - self.yawDeg 
                   
            self.rollDeg = euler[1]
            self.rollRad = euler[1]*3.14159/180.0
            #Grab corrected pitch
            self.pitchDeg = euler[3]
            self.pitchRad = euler[3]*3.14159/180.0   
            #Grab corrected yaw
            self.yawDeg = -euler[5]
            self.yawRad = -euler[5]*3.14159/180.0 
                               
        self.update()
                
    def paintGL(self):
        
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)  
 
        #Draw a grid on the floor
#         glDisable(GL_LIGHTING)
#         glLineWidth(1)
#         glColor3f(.6, .6, .6)        
#         glPushMatrix()
#         glBegin(GL_LINES)
#         for i in numpy.arange(-.9, 1, 0.1):
#             glVertex3f(i, -.9, .9)
#             glVertex3f(i, -.9, -.9)
#             glVertex3f(.9, -.9, i)
#             glVertex3f(-.9, -.9, i)
#         glEnd()
#         glPopMatrix()
        
        glEnable(GL_LIGHTING)
        
        #Draw axis
        glPushMatrix()
        glColor3f(1.0, 0.0, 0.0)
        glTranslated(.9, -.4, -.9)
        glRotatef(90, 1.0, 0.0, 0.0)
        gluCylinder(self.quadratic, 0.01,0.01,0.5,15,15)
        glPopMatrix()

        glPushMatrix()
        glColor3f(1.0, 0.0, 0.0)    
        glTranslated(.9, -.4, -.9)
        glRotatef(-90, 1.0, 0.0, 0.0)
        glutSolidCone( .04, .06, 15,15)
        glPopMatrix()
        
        glPushMatrix()
        glColor3f(1.0, 0.0, 0.0)
        glTranslated(.9, -.9, -.9)
        #glRotatef(90, 1.0, 0.0, 0.0)
        gluCylinder(self.quadratic, 0.01,0.01,0.5,15,15)
        glPopMatrix()

        glPushMatrix()
        glColor3f(1.0, 0.0, 0.0)      
        glTranslated(.9, -.9, -.4)
        #glRotatef(90, 0.0, 1.0, 0.0)
        glutSolidCone( .04, .06, 15,15)
        glPopMatrix()
        
        glPushMatrix()
        glColor3f(1.0, 0.0, 0.0)
        glTranslated(.4, -.9, -.9)
        glRotatef(90, 0.0, 1.0, 0.0)
        gluCylinder(self.quadratic, 0.01,0.01,0.5,15,15)
        glPopMatrix()

        glPushMatrix()
        glColor3f(1.0, 0.0, 0.0)      
        glTranslated(.4, -.9, -.9)
        glRotatef(90, 0.0, 1.0, 0.0)
        glutSolidCone( .04, .06, 15,15)
        glPopMatrix()
                      
        glPushMatrix();
        glRotatef(self.yawDeg,   0.0, 1.0, 0.0);
        glRotatef(self.pitchDeg, 0.0, 0.0, 1.0);
        glRotatef(self.rollDeg,  1.0, 0.0, 0.0);
           
        self.prevRollDeg = self.rollDeg
        self.prevYawDeg = self.yawDeg
        self.prevPitchDeg = self.pitchDeg
            
        glPushMatrix();    
        glLineWidth(3)      
        # draw t
        glBegin(GL_QUADS)
        glColor3f(1.0, 1.0, 1.0)
        
        glNormal3f( 1.0, 0.0,1.0) 
        glVertex3f( 0.75, 0.1, 0.1)
        glVertex3f( 0.75,-0.1, 0.1)
        glVertex3f(  .9,  0.0, 0.0)
        glVertex3f(  .9,  0.0, 0.0)
        
        glNormal3f( 1.0, 0.0,-1.0) 
        glVertex3f( 0.75, 0.1, -0.1)
        glVertex3f( 0.75,-0.1, -0.1)
        glVertex3f(  .9,  0.0, 0.0)
        glVertex3f(  .9,  0.0, 0.0)
             
        glNormal3f( 1.0, 1.0,0.0)
        glVertex3f(  0.75, 0.1, 0.1)
        glVertex3f(  0.75, 0.1, -0.1)        
        glVertex3f(  .9,  0.0, 0.0)
        glVertex3f(  .9,  0.0, 0.0)

        glNormal3f( 1.0, -1.0, 0.0)        
        glVertex3f(  0.75, -0.1, 0.1)
        glVertex3f(  0.75, -0.1, -0.1)
        glVertex3f(  .9,  0.0, 0.0)
        glVertex3f(  .9,  0.0, 0.0)

        glNormal3f( 1.0, 0.0,0.0)
        glVertex3f( 0.75, 0.1, 0.1)
        glVertex3f( 0.75,-0.1, 0.1)
        glVertex3f( 0.75,-0.1,-0.1)
        glVertex3f( 0.75, 0.1,-0.1)
     
        glNormal3f( 0.0, 0.0,1.0)        
        glVertex3f( 0.75, 0.01, 0.01)
        glVertex3f(-0.75, 0.01, 0.01)
        glVertex3f(-0.75,-0.01, 0.01)
        glVertex3f( 0.75,-0.01, 0.01)

        glNormal3f( 0.0, 0.0,-1.0)
        glVertex3f(-0.75,-0.01,-0.01)
        glVertex3f(-0.75, 0.01,-0.01)
        glVertex3f( 0.75, 0.01,-0.01)
        glVertex3f( 0.75,-0.01,-0.01)

        glNormal3f( 0.0, 1.0, 0.0)
        glVertex3f( 0.75, 0.01, 0.01)
        glVertex3f( 0.75, 0.01,-0.01)
        glVertex3f(-0.75, 0.01,-0.01)
        glVertex3f(-0.75, 0.01, 0.01)

        glNormal3f( 0.0,-1.0, 0.0)
        glVertex3f(-0.75,-0.01,-0.01)
        glVertex3f( 0.75,-0.01,-0.01)
        glVertex3f( 0.75,-0.01, 0.01)
        glVertex3f(-0.75,-0.01, 0.01)

        glNormal3f( 1.0, 0.0, 0.0)
        glVertex3f( 0.75, 0.01, 0.01)
        glVertex3f( 0.75,-0.01, 0.01)
        glVertex3f( 0.75,-0.01,-0.01)
        glVertex3f( 0.75, 0.01,-0.01)

        glNormal3f(-1.0, 0.0, 0.0)
        glVertex3f(-0.75,-0.01,-0.01)
        glVertex3f(-0.75,-0.01, 0.01)
        glVertex3f(-0.75, 0.01, 0.01)
        glVertex3f(-0.75, 0.01,-0.01)

        # draw six faces of a cube
        glColor3f(1.0, 0.0, 0.0)
        glNormal3f( 0.0, 0.0, 1.0)
        glVertex3f( 0.25, 0.25, 0.25)
        glVertex3f(-0.25, 0.25, 0.25)
        glVertex3f(-0.25,-0.25, 0.25)
        glVertex3f( 0.25,-0.25, 0.25)

        glNormal3f( 0.0, 0.0,-1.0)
        glVertex3f(-0.25,-0.25,-0.25)
        glVertex3f(-0.25, 0.25,-0.25)
        glVertex3f( 0.25, 0.25,-0.25)
        glVertex3f( 0.25,-0.25,-0.25)

        glNormal3f( 0.0, 1.0, 0.0)
        glVertex3f( 0.25, 0.25, 0.25)
        glVertex3f( 0.25, 0.25,-0.25)
        glVertex3f(-0.25, 0.25,-0.25)
        glVertex3f(-0.25, 0.25, 0.25)

        glNormal3f( 0.0,-1.0, 0.0)
        glVertex3f(-0.25,-0.25,-0.25)
        glVertex3f( 0.25,-0.25,-0.25)
        glVertex3f( 0.25,-0.25, 0.25)
        glVertex3f(-0.25,-0.25, 0.25)

        glNormal3f( 1.0, 0.0, 0.0)
        glVertex3f( 0.25, 0.25, 0.25)
        glVertex3f( 0.25,-0.25, 0.25)
        glVertex3f( 0.25,-0.25,-0.25)
        glVertex3f( 0.25, 0.25,-0.25)

        glNormal3f(-1.0, 0.0, 0.0)
        glVertex3f(-0.25,-0.25,-0.25)
        glVertex3f(-0.25,-0.25, 0.25)
        glVertex3f(-0.25, 0.25, 0.25)
        glVertex3f(-0.25, 0.25,-0.25)
        glEnd()  
        glPopMatrix();
        
        glNormal3f( 1.0, 1.0,1.0) #Light hitting all axis'
        glColor3f(1,1,1);
        glPushMatrix();
        glTranslatef(.75,-.25,.01);
        glScalef(.001, .001, .001);
        glLineWidth(3);        
        for ch in str('x'):
            glutStrokeCharacter(GLUT_STROKE_ROMAN, ord(ch));
        glPopMatrix();
        glPopMatrix();
        
        glFlush()

    def resizeGL(self, widthInPixels, heightInPixels):
        glViewport(0, 0, widthInPixels, heightInPixels)

    def initializeGL(self):
        glutInit()
        glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB)
        glMatrixMode(GL_PROJECTION)
        glFrustum(-0.5, 0.5, -0.5, 0.5, 1.0, 3.0)

        # position viewer
        glMatrixMode(GL_MODELVIEW)
        glTranslatef(0.0, 0.0, -2.0)

        # position object
        glRotatef(0, 1.0, 0.0, 0.0)
        glRotatef(90, 0.0, 1.0, 0.0)
        glRotatef(0, 0.0, 0.0, 1.0)
        
        glEnable ( GL_COLOR_MATERIAL )
        glEnable(GL_DEPTH_TEST)
        glEnable(GL_LIGHTING)
        glEnable(GL_LIGHT0)
        glColorMaterial ( GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE )
        glClearColor( .35,.35,.35, 1)
        self.quadratic = gluNewQuadric(); 
        
class calibrationView(QGLWidget):

    def __init__(self, parent):
        QGLWidget.__init__(self, parent)
        self.setMouseTracking(True)
        #self.setMaximumSize(600, 600)
        #self.setMinimumSize(400, 400)

        self.isPressed = False
        self.oldx = self.oldy = 0
        self.delta_x = self.delta_y = 0

        self.numPoints = 0
        self.points = (numpy.zeros([100,3]))
        
        self.rotMat = numpy.matrix([[0.,0.,0.],[0.,0.,0.],[0.,0.,0.]])
        self.scale = numpy.matrix([[0.0],[0.0],[0.0]])
        self.bias = numpy.matrix([[0.],[0.],[0.]])
        self.showCorrection = False
        self.enSpin = False
        self.phase = 0
        self.startTimer(100)
    
    def reset(self):
        self.isPressed = False
        self.oldx = self.oldy = 0
        self.delta_x = self.delta_y = 0

        self.numPoints = 0
        self.points = (numpy.zeros([100,3]))
        
        self.rotMat = numpy.matrix([[0.,0.,0.],[0.,0.,0.],[0.,0.,0.]])
        self.scale = numpy.matrix([[0.0],[0.0],[0.0]])
        self.bias = numpy.matrix([[0.],[0.],[0.]])
        self.showCorrection = False
        self.enSpin = False
        self.phase = 0.0
        self.startTimer(25)
        
    def glReset(self):
        glMatrixMode(GL_MODELVIEW)
        #Reset the view
        glLoadIdentity()
        #Rest the viewer
        glTranslatef(0.0, 0.0, -3)
        glRotatef(0, 0, 1, 0)
        glRotatef(0, 1, 0, 0)
        glRotatef(0, 0, 0, 1)
        
        glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST)
                            
    def timerEvent(self, e):
        if( self.enSpin == True):
            self.update()
                 
    def updateRotMat(self, rotMat):  
        self.rotMat = rotMat;

    def updateScale(self, scale):  
        self.scale = scale;

    def updateBias(self, bias):  
        self.bias = bias;
                          
    def updataDataPoint(self, point, index, totalPoints): 
        
        self.numPoints = numpy.int(index + 1)
        self.points[numpy.int(index)] = point
        print( self.points[index], index)
        self.update()
                
    def paintGL(self):
        
        glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
        
        #Draw a grid on the floor
#         glDisable(GL_LIGHTING)
#         glColor3f(.6, .6, .6)        
#         glPushMatrix()
#         glBegin(GL_LINES)
#         for i in numpy.arange(-3, 3.2, 0.2):
#             glVertex3f(i, -4, 3)
#             glVertex3f(i, -4, -3)
#             glVertex3f(3, -4, i)
#             glVertex3f(-3, -4, i)
#         glEnd()
#         glPopMatrix()
        
        glEnable(GL_LIGHTING)
        
        #Draw axis
        glPushMatrix()
        glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, (1, 0, 0))
        glTranslated(-3, -2, -3)
        glRotatef(90, 1.0, 0.0, 0.0)
        gluCylinder(self.quadratic, 0.05,0.05,2.0,15,15)
        glPopMatrix()

        glPushMatrix()
        glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, (1, 0, 0))      
        glTranslated(-3, -2, -3)
        glRotatef(-90, 1.0, 0.0, 0.0)
        glutSolidCone( .15, .5, 15,15)
        glPopMatrix()
        
        glPushMatrix()
        glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, (1, 0, 0))
        glTranslated(-3, -4, -3)
        #glRotatef(90, 1.0, 0.0, 0.0)
        gluCylinder(self.quadratic, 0.05,0.05,2.0,15,15)
        glPopMatrix()

        glPushMatrix()
        glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, (1, 0, 0))      
        glTranslated(-1, -4, -3)
        glRotatef(90, 0.0, 1.0, 0.0)
        glutSolidCone( .15, .5, 15,15)
        glPopMatrix()
        
        glPushMatrix()
        glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, (1, 0, 0))
        glTranslated(-3, -4, -3)
        glRotatef(90, 0.0, 1.0, 0.0)
        gluCylinder(self.quadratic, 0.05,0.05,2.0,15,15)
        glPopMatrix()

        glPushMatrix()
        glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, (1, 0, 0))      
        glTranslated(-3, -4, -1)
        #glRotatef(90, 0.0, 1.0, 0.0)
        glutSolidCone( .15, .5, 15,15)
        glPopMatrix()
                                
        glPushMatrix()
        if( self.enSpin == True):
            self.phase = self.phase + .5;
            if( self.phase > 360):
                self.phase = 360 - self.phase
                
        glRotatef(0, 1.0, 0.0, 0.0);
        glRotatef(self.phase, 0.0, 1.0, 0.0);
        glRotatef(0, 0.0, 0.0, 1.0);
                       
        glPushMatrix()       
        #glColor3f(0, 0, 0)
        glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, (0, 0, 0)) 
        glTranslated(0, 0, 0)
        glRotatef(90, 1.0, 0.0, 0.0)
        glutWireSphere(1,12,12)
        glPopMatrix()
                     
        for i in range(0,self.numPoints):
            if( TEST_MAG_DATA == 1):
                self.points[i] = magTestData[i]  
                          
            if( self.showCorrection == True):
                
                #remove bias                                      
                points1 = numpy.matrix( [[self.points[i][0]], [self.points[i][1]], [self.points[i][2]]])
              
                points1[0][0] = points1.item(0) - self.bias.item(0)
                points1[1][0] = points1.item(1) - self.bias.item(1)
                points1[2][0] = points1.item(2) - self.bias.item(2)

                #Rotate object to 0, based on principle axis
                points2 = self.rotMat*points1
 
                #Scale the amplitude of the points
                points3 = numpy.matrix( [[points2.item(0)*self.scale.item(0)],[points2.item(1)*self.scale.item(1)],[points2.item(2)*self.scale.item(2)]])

                #Point back to original location
                points4 = numpy.transpose(self.rotMat)*points3
                glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, (1, 0, 0))      
                glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 20.);              
                glPushMatrix()
                glTranslated(points4[0][0], points4[1][0], points4[2][0])
                glutSolidSphere(.05,100,100)          
                glPopMatrix()
             
            glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, (0, 1, 0))
            glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 20.);   
            glPushMatrix()
            glTranslated(self.points[i][0], self.points[i][1], self.points[i][2])
            glutSolidSphere(.05,100,100)          
            glPopMatrix()
        glPopMatrix()                
        glFlush();

    def mouseMoveEvent(self, mouseEvent):
        if int(mouseEvent.buttons()) != QtCore.Qt.NoButton :
            # user is dragging
            self.delta_x = mouseEvent.x() - self.oldx
            self.delta_y = self.oldy - mouseEvent.y()
            self.update()
        self.oldx = mouseEvent.x()
        self.oldy = mouseEvent.y()
                    
    def resizeGL(self, widthInPixels, heightInPixels):
        glViewport(0, 0, widthInPixels, heightInPixels)
        glFrustum(-2, 2, -1.5, 1.5, 1, 40)
        self.glReset()
        
    def initializeGL(self):
        glutInit()
        glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH)
        #glutInitWindowSize( 500,500)
        glClearColor(0.1, 0.39, 0.88, 1.0)
        glColor3f(1.0, 1.0, 1.0)
        
        glEnable(GL_CULL_FACE)
        glCullFace(GL_BACK)
        
        glMatrixMode(GL_PROJECTION)
        glLoadIdentity()
        glFrustum(-2, 2, -1.5, 1.5, 1, 40)
        
        glEnable(GL_DEPTH_TEST)
        glLightfv(GL_LIGHT0, GL_AMBIENT, (1,1,1))
        glLightfv(GL_LIGHT0, GL_DIFFUSE, (1,1,1))
        glLightfv(GL_LIGHT0, GL_SPECULAR, (1,1,1))
        glMaterialfv(GL_FRONT, GL_SPECULAR, (1,1,1))
        glMaterialf(GL_FRONT, GL_SHININESS, 30)
        glEnable(GL_LIGHTING)
        glEnable(GL_LIGHT0)
        #glClearColor( .55,.55,.55, 1)
        self.quadratic = gluNewQuadric();   
        self.glReset()

class ahrsMain(QtGui.QMainWindow):
    def __init__(self):
        QtGui.QWidget.__init__(self)
        self.setWindowTitle('Arbitros AHRS')
        self.statusBar().showMessage("Version 1.0")

        exit = QtGui.QAction("Exit", self)
        exit.setShortcut("Ctrl+Q")
        exit.setStatusTip('Exit application')
        self.connect(exit, QtCore.SIGNAL('triggered()'), QtCore.SLOT('close()'))

        arbConnect = QtGui.QAction("Serial", self)
        arbConnect.setStatusTip('Connect the device serial port')
        self.connect(arbConnect, QtCore.SIGNAL('triggered()'), self.arbConnect)   
        
        threeDView = QtGui.QAction("3D", self)
        threeDView.setStatusTip('Display the roll, pitch, and yaw')
        self.connect(threeDView, QtCore.SIGNAL('triggered()'), self.threeDView)  

        plotView = QtGui.QAction("XY", self)
        plotView.setStatusTip('X,Y plot of roll, pitch, and yaw')
        self.connect(plotView, QtCore.SIGNAL('triggered()'), self.plotView) 
        
        arbCal = QtGui.QAction("Calibration", self)
        arbCal.setStatusTip('Calibrate the accelerometer and magnetometer')
        self.connect(arbCal, QtCore.SIGNAL('triggered()'), self.arbCal) 
                   
        self.stack = QtGui.QStackedWidget()
        
        menubar = self.menuBar()
        fileMenu = menubar.addMenu('&File')
        viewMenu = menubar.addMenu('&Views')
        connectMenu = menubar.addMenu('&Connection')
        fileMenu.addAction(exit)
        connectMenu.addAction(arbConnect)
        viewMenu.addAction(threeDView)
        viewMenu.addAction(plotView)
        viewMenu.addAction(arbCal)
         
        self.viewer3D    = Viewer3DWidget(self)
        self.headingPlot = XyPlotCompass(self)
        self.attPlot     = XyPlotPitchRoll(self)
           
        threeDWidget = QtGui.QWidget()
        connWidget = QtGui.QWidget()
        calWidget = QtGui.QWidget()
        plotWidget = QtGui.QWidget()
        
        self.viewer3D.setSizePolicy( QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding )
        self.headingPlot.setSizePolicy( QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding )
        self.attPlot.setSizePolicy( QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding )
        
        calBox = QtGui.QHBoxLayout()
        calButtonLayoutH = QtGui.QHBoxLayout()
        calButtonLayoutV = QtGui.QVBoxLayout()
        self.calPlot = calibrationView(self)
        
        self.startCalButton = QtGui.QPushButton("Start")
        self.startCalButton.setStatusTip('Begin calibration')
        self.connect(self.startCalButton, QtCore.SIGNAL('clicked()'), self.startCal)
        
        self.acquireCalSamp = QtGui.QPushButton("Capture Point")
        self.acquireCalSamp.setStatusTip('Rotate the device to a new position, hold, then press to capture point.')
        self.connect(self.acquireCalSamp, QtCore.SIGNAL('clicked()'), self.acquireCalPushed)
        self.acquireCalSamp.setEnabled(False)
                
        self.calCombo = QtGui.QComboBox(self)
        self.calCombo.setStatusTip('Select meter to calibrate') 
        self.calCombo.addItems(['magnetometer','accelerometer'])
        self.calType = 'magnetometer'
        self.calCombo.activated[str].connect(self.calSelected)
        
        calButtonLayoutH.addWidget(self.calCombo)
        calButtonLayoutH.addWidget(self.startCalButton)
        calButtonLayoutV.addLayout(calButtonLayoutH)
        calButtonLayoutV.addWidget(self.acquireCalSamp)
        self.calTextBox = QtGui.QPlainTextEdit()
        self.calTextBox.setFixedWidth( 300)
        self.calTextBox.setReadOnly( True)
        calButtonLayoutV.addWidget(self.calTextBox)
        calButtonLayoutV.setAlignment(QtCore.Qt.AlignTop)
          
        calBox.addWidget(self.calPlot, 1)
        
        calBox.addLayout(calButtonLayoutV)
                        
        graphBox = QtGui.QHBoxLayout()  
        self.rollPlot = AHRSPlot(plotName='Roll Plot', yName='Roll (degrees)')
        self.pitchPlot = AHRSPlot(plotName='Pitch Plot', yName='Pitch (degrees)')
        self.yawPlot = AHRSPlot(plotName='Yaw Plot', yName='Yaw (degrees)')
        graphBox.addWidget( self.rollPlot)
        graphBox.addWidget( self.pitchPlot)
        graphBox.addWidget( self.yawPlot)
            
        mainBox = QtGui.QHBoxLayout() 
        mainBox2 = QtGui.QHBoxLayout() 
        mainBox3 = QtGui.QVBoxLayout() 
        mainBox.addWidget( self.viewer3D)
        mainBox.addWidget( self.headingPlot)
        mainBox.addWidget( self.attPlot)
        mainBox.setAlignment(QtCore.Qt.AlignCenter)
        
        self.rawButton = QtGui.QPushButton("Plot Uncorrected")
        self.rawButton.setStatusTip('Use Raw Measurements')
        self.connect(self.rawButton, QtCore.SIGNAL('clicked()'), self.rawButtonClicked)        
        
        mainBox2.addWidget(self.rawButton)
        mainBox2.setAlignment(QtCore.Qt.AlignLeft)
        mainBox3.addLayout(mainBox2)
        mainBox3.addLayout(mainBox)
        
        plotWidget.setLayout(graphBox)        
        threeDWidget.setLayout(mainBox3)
        calWidget.setLayout(calBox)
        
        button1 = QtGui.QPushButton("Connect")
        button1.setStatusTip('Connect to the device.')
        self.connect(button1, QtCore.SIGNAL('clicked()'), self.button1Action)
        button2 = QtGui.QPushButton("Disconnect")
        button2.setStatusTip('Disconnect from device')
        self.connect(button2, QtCore.SIGNAL('clicked()'), self.button2Action)
        portBox = QtGui.QComboBox(self)
        portBox.setStatusTip('Available Serial Ports')              
        buttonBox = QtGui.QVBoxLayout()
        buttonBox.addWidget(button1)
        buttonBox.addWidget(portBox)
        buttonBox.addWidget(button2)
        #buttonBox.addWidget(button3)
        buttonBox.addStretch(1)
        
        subBox = QtGui.QHBoxLayout()
        subBox.addLayout(buttonBox)
       
        connWidget.setLayout(subBox)

        self.stack.addWidget(threeDWidget)
        self.stack.addWidget(connWidget)
        self.stack.addWidget(calWidget)     
        self.stack.addWidget(plotWidget)
        
        self.setCentralWidget(self.stack)
        self.stack.setCurrentIndex(1) 
        
        self.serialPort = serial.Serial()
        self.serialPort.baudrate = 115200
        self.serialPort.bytesize = serial.EIGHTBITS  
        self.serialPort.parity = serial.PARITY_NONE
        self.serialPort.stopbits = serial.STOPBITS_ONE
        self.serialPort.port = 'COM20'
        self.serialPort.timeout = None
        self.serialOpen = False

        self.serialPorts = list(self.serial_ports())
        portBox.addItems(self.serialPorts)
        portBox.activated[str].connect(self.portSelected)    
        self.thread = SerialReader("serialReader", self.serialPort) 
        self.connect(self.thread, self.thread.signal, self.setData)
        
        screenWidth = QtGui.QApplication.desktop().width()
        screenHeight = QtGui.QApplication.desktop().height()
 
        self.resize(600,200)
        
        windowSize = self.size()
        width = windowSize.width() 
        height = windowSize.height()
 
        x = (screenWidth - width) / 2
        y = (screenHeight - height) / 2
        y -= 50
        self.move ( x, y )
        self.navState = NAV_IDLE
        self.startTimer( TIMER_UPDATE_RATE)

    def rawButtonClicked(self):
        if( self.viewer3D.useRawMeas == False):
            self.rawButton.setText("Plot Corrected")
            self.attPlot.useRawMeas = True
            self.headingPlot.useRawMeas = True     
            self.viewer3D.useRawMeas = True
        else:
            self.rawButton.setText("Plot Uncorrected")
            self.attPlot.useRawMeas = False
            self.headingPlot.useRawMeas = False              
            self.viewer3D.useRawMeas = False
        
    def acquireCalPushed(self):
        if self.serialOpen == True:
            byteMsg = bytes("\r", 'UTF-8')
            self.serialPort.write(byteMsg) 
            self.acquireCalSamp.setEnabled(False)
                            
    def calSelected(self, text):
        self.calType = text
        print( text)
        
    def startCal(self):
        if self.serialOpen == True:
            self.calTextBox.clear()
            reply = QtGui.QMessageBox.question(self, "Confirmation", "Beginning device calibration. Each time the 'Capture Point' button becomes available, rotate the device to a new position, hold it steady, then press enter to capture the new point.", QtGui.QMessageBox.Yes | QtGui.QMessageBox.No, QtGui.QMessageBox.No)
            if reply != QtGui.QMessageBox.Yes:
                self.startCalButton.setEnabled( True)
                self.calCombo.setEnabled( True)          
            else:
                if( self.calType == "magnetometer"):
                    byteMsg = bytes("pmc\r", 'UTF-8')
                    self.serialPort.write(byteMsg) 
                else:
                    byteMsg = bytes("pac\r", 'UTF-8')
                    self.serialPort.write(byteMsg) 
                    
            self.startCalButton.setEnabled( False)
            self.calCombo.setEnabled( False)
            self.calPlot.reset()
            self.calPlot.glReset()
                                     
    def setData(self, mess):
        if(self.stack.currentIndex() != 2):           
            state = numpy.array(list(map(float, mess)))
            index = 0
            for val in state:
                state[index] = numpy.float(numpy.int(val*100)/100)
                index = index + 1            
            self.attPlot.setRollPitch( state)
            self.headingPlot.setYaw(state)
            self.viewer3D.setRollPitchYaw(state)
            if( state[6] > 0.0):
                state[6] = 1.0     
            self.rollPlot.updateAngles(state[0], state[1], state[6], state[7])
            self.pitchPlot.updateAngles(state[2], state[3], state[6], state[8])
            self.yawPlot.updateAngles(state[4], state[5], state[6], state[9])
            self.navState = state[10]
            print( self.navState)
            
        else:
            print(mess[0])
            if( mess[0] == '#collect'):
                self.acquireCalSamp.setEnabled(True)
                self.calTextBox.appendPlainText( "Rotate device to new location, click \'Capture Point\' when ready.")
                
            elif( mess[0] == '#cal3dpoint'):
                mess = mess[1:len(mess)]
                data = numpy.array(list(map(float, mess)))
                index = 0
                for val in data:
                    data[index] = numpy.float(numpy.int(val*100)/100)
                    index = index + 1  
                    
                if( TEST_MAG_DATA == 0):
                    point = data[0:3]
                else:
                    point = magTestData[numpy.int(data[3])] 
                       
                self.calPlot.updataDataPoint(point, data[3], data[4])
                z = "x=%f y=%f z=%f" %(point[0],point[1],point[2])
                self.calTextBox.appendPlainText(z)
                    
            elif( mess[0] == '#result'):
                print( mess[1])  
                if( mess[1] == 'passed'):
                    self.calPlot.showCorrection = True
                    self.calPlot.enSpin = True

                    rotMat = self.calPlot.rotMat          
                    self.calPlot.updateRotMat(rotMat)
                    z = "Rotation matrix = [[%f,%f,%f],[%f,%f,%f],[%f,%f,%f]]" %(rotMat.item(0),rotMat.item(1),rotMat.item(2),rotMat.item(3),rotMat.item(4),rotMat.item(5),rotMat.item(6),rotMat.item(7),rotMat.item(8))
                    self.calTextBox.appendPlainText(z) 
                    
                    sc = self.calPlot.scale                                      
                    self.calPlot.updateScale(sc)
                    z = "Axis scale = %f,%f,%f" %(sc.item(0),sc.item(1),sc.item(2))
                    self.calTextBox.appendPlainText(z)   

                    bi= self.calPlot.bias                  
                    self.calPlot.updateBias(bi) 
                    z = "Axis bias = %f,%f,%f" %(bi.item(0),bi.item(1),bi.item(2))
                    self.calTextBox.appendPlainText(z)
                    self.calPlot.showCorrection = True
                    self.calPlot.enSpin = True
                    self.calPlot.update()
                                        
                else:
                    self.calPlot.showCorrection = False
                         
                self.startCalButton.setEnabled( True)
                self.calCombo.setEnabled( True)      
                self.acquireCalSamp.setEnabled(False)
                if( TEST_MAG_DATA == 1):
                    
                    self.calTextBox.appendPlainText("Calibration passed")
  
                    rotMat = magTestRotMat          
                    self.calPlot.updateRotMat(rotMat)
                    z = "Rotation matrix = [[%f,%f,%f],[%f,%f,%f],[%f,%f,%f]]" %(rotMat.item(0),rotMat.item(1),rotMat.item(2),rotMat.item(3),rotMat.item(4),rotMat.item(5),rotMat.item(6),rotMat.item(7),rotMat.item(8))
                    self.calTextBox.appendPlainText(z) 
                    
                    sc = magTestScale                                      
                    self.calPlot.updateScale(sc)
                    z = "Axis scale = %f,%f,%f" %(sc.item(0),sc.item(1),sc.item(2))
                    self.calTextBox.appendPlainText(z)   

                    bi= magTestBias                  
                    self.calPlot.updateBias(bi) 
                    z = "Axis bias = %f,%f,%f" %(bi.item(0),bi.item(1),bi.item(2))
                    self.calTextBox.appendPlainText(z)
                    self.calPlot.showCorrection = True
                    self.calPlot.enSpin = True
                    self.calPlot.update()
                                                                        
                else:
                    z = "Calibration %s" %(mess[1])
                    self.calTextBox.appendPlainText(z)

                                                                    
            elif(  mess[0] == '#calrotmatrix'):
                mess = mess[1:len(mess)]
                rotMat = numpy.array(list(map(float, mess)))
                
                index = 0
                for val in rotMat:
                    rotMat[index] = numpy.float(numpy.int(val*100)/100)
                    index = index + 1  
                    
                if( TEST_MAG_DATA == 0):    
                    rotMat2 = numpy.matrix([[rotMat[0],rotMat[1],rotMat[2]],
                                          [rotMat[3],rotMat[4],rotMat[5]],
                                          [rotMat[6],rotMat[7],rotMat[8]]])
                else:
                    rotMa2t = magTestRotMat
                print(rotMat2)
                self.calPlot.updateRotMat(rotMat2)
             
            elif(  mess[0] == '#axisscale'):
                mess = mess[1:len(mess)]
                scale = numpy.array(list(map(float, mess)))
                index = 0
                for val in scale:
                    scale[index] = numpy.float(numpy.int(val*100)/100)
                    index = index + 1  
                
                if( TEST_MAG_DATA == 0): 
                    sc = numpy.matrix([[scale[0]],[scale[1]],[scale[2]]])
                else:
                    sc = magTestScale
                                                       
                self.calPlot.updateScale(sc)
                               
            elif(  mess[0] == '#axisbias'):
                mess = mess[1:len(mess)]   
                bias = numpy.array(list(map(float, mess)))
                index = 0
                for val in bias:
                    bias[index] = numpy.float(numpy.int(val*100)/100)
                    index = index + 1 
                
                if( TEST_MAG_DATA == 0):
                    bi = numpy.matrix([[bias[0]],[bias[1]],[bias[2]]]) 
                else:
                    bi= magTestBias
                               
                self.calPlot.updateBias(bi) 
                                                                                            
    def timerEvent(self, e):
        if (self.serialOpen == True) and (self.stack.currentIndex() != 2):
            #Get the latest tracking data
            byteMsg = bytes("gsd\r", 'UTF-8')
            self.serialPort.write(byteMsg)     

    def arbCal(self):
        self.stack.setCurrentIndex(2) 
        self.startCalButton.setEnabled( True)
        self.calCombo.setEnabled( True)
        #Make sure the device is in the idle state
        byteMsg = bytes("sis\r", 'UTF-8')
        self.serialPort.write(byteMsg)
                       
    def plotView(self):
        self.stack.setCurrentIndex(3)  
        #Make sure the device is in the active state
        byteMsg = bytes("sas\r", 'UTF-8')
        self.serialPort.write(byteMsg) 
                        
    def arbConnect(self):
        self.stack.setCurrentIndex(1)
        
    def threeDView(self):
        self.stack.setCurrentIndex(0)
        #Make sure the device is in the active state
        byteMsg = bytes("sas\r", 'UTF-8')
        self.serialPort.write(byteMsg) 
                                        
    def portSelected(self, text):
        self.serialPort.port = text
          
    def closeEvent(self, event):
        reply = QtGui.QMessageBox.question(self, "Confirmation",
            "Are you sure to quit?", QtGui.QMessageBox.Yes | QtGui.QMessageBox.No, QtGui.QMessageBox.No)
        if reply == QtGui.QMessageBox.Yes:
            event.accept()
        else:
            event.ignore()
            
    def button1Action( self ):     
        if self.serialOpen == False:
            self.serialOpen = True    
            self.serialPort.open()
            self.serialPort.flushInput() #flush input buffer, discarding all its contents
            self.serialPort.flushOutput() #flush output buffer, aborting current output          
            self.thread.start()
            #Make sure the device is in the idle state
            byteMsg = bytes("sas\r", 'UTF-8')
            self.serialPort.write(byteMsg)            
            self.stack.setCurrentIndex(0)
                   
    def button2Action( self ):
        if self.serialOpen == True:
            self.serialOpen = False
            self.thread.terminate()
            self.serialPort.close()
            self.stack.setCurrentIndex(0)
            
    def serial_ports(self):
        """
        Returns a generator for all available serial ports
        """
        if os.name == 'nt':
            # windows
            for i in range(256):
                try:
                    s = serial.Serial(i)
                    s.close()
                    yield 'COM' + str(i + 1)
                except serial.SerialException:
                    pass
        else:
            # unix
            for port in list_ports.comports():
                yield port[0]

        
if __name__ == '__main__':
    colorScheme = QColorScheme(spread=5)
    app = QtGui.QApplication(sys.argv)
    
    window = ahrsMain()
    colorScheme.applyStyle(target=window)
    window.show()
    sys.exit(app.exec_())

